// Generated by CoffeeScript 1.6.3
var EventEmitter, Readable, arraydiff, assert, deepEquals, ot, redisLib,
  __slice = [].slice;

Readable = require('stream').Readable;

EventEmitter = require('events').EventEmitter;

assert = require('assert');

deepEquals = require('deep-is');

redisLib = require('redis');

arraydiff = require('arraydiff');

ot = require('./ot');

exports.client = function(snapshotDb, redis, extraDbs) {
  var client, getDocOpChannel, getOpLogKey, nextStreamId, prefixChannel, redisObserver, redisSubmit, streams, subscribeCounts;
  if (redis == null) {
    redis = redisLib.createClient();
  }
  if (extraDbs == null) {
    extraDbs = {};
  }
  streams = {};
  nextStreamId = 0;
  redisObserver = redisLib.createClient(redis.port, redis.host, redis.options);
  if (redis.auth_pass) {
    redisObserver.auth(redis.auth_pass);
  }
  redisObserver.setMaxListeners(0);
  subscribeCounts = {};
  prefixChannel = function(channel) {
    return "" + (redis.selected_db || 0) + " " + channel;
  };
  getOpLogKey = function(cName, docName) {
    return "" + cName + "." + docName + " ops";
  };
  getDocOpChannel = function(cName, docName) {
    return "" + cName + "." + docName;
  };
  redisSubmit = function(cName, docName, opData, callback) {
    var docPubEntry, logEntry;
    logEntry = JSON.stringify({
      op: opData.op,
      src: opData.src,
      seq: opData.seq,
      create: opData.create,
      del: opData.del
    });
    docPubEntry = JSON.stringify(opData);
    return redis["eval"]("-- ops here is a JSON string.\nlocal clientNonceKey, opLogKey, docOpChannel = unpack(KEYS)\nlocal seq, v, logEntry, docPubEntry = unpack(ARGV) -- From redisSubmit, below.\nv = tonumber(v)\nseq = tonumber(seq)\n\n-- Check the version matches.\nlocal realv = redis.call('LLEN', opLogKey)\n\nif v < realv then\n  --redis.log(redis.LOG_NOTICE, \"k: \" .. opLogKey .. \" v: \" .. v)\n  return redis.call('LRANGE', opLogKey, v, -1)\nelseif v > realv then\n  return \"Version from the future\"\nend\n\n-- Dedup, but only if the id has been set.\nif seq ~= nil then\n  local nonce = redis.call('GET', clientNonceKey)\n  if nonce ~= false and tonumber(nonce) >= seq then\n    return \"Op already submitted\"\n  end\nend\n\n-- Ok to submit. Save the op in the oplog and publish.\nredis.call('RPUSH', opLogKey, logEntry)\nredis.call('PUBLISH', docOpChannel, docPubEntry)\n\n-- Finally, save the new nonce. We do this here so we only update the nonce if\n-- we're at the most recent version in the oplog.\nif seq ~= nil then\n  --redis.log(redis.LOG_NOTICE, \"set \" .. clientNonceKey .. \" to \" .. seq)\n  redis.call('SET', clientNonceKey, seq)\n  redis.call('EXPIRE', clientNonceKey, 60*60*24*7) -- 1 week\nend", 3, opData.src, getOpLogKey(cName, docName), prefixChannel(getDocOpChannel(cName, docName)), opData.seq, opData.v, logEntry, docPubEntry, callback);
  };
  return client = {
    /*
    create: (cName, docName, type, initialData, meta, callback) ->
      # Not matching all possible cases here. Eh.
      [initialData, callback] = [null, initialData] if typeof initialData is 'function'
      [meta, callback] = [{}, meta] if typeof meta is 'function'
    
      type = otTypes[type] if typeof type is 'string'
      return callback? new Error 'Type not found' unless type
    
      # + NOTIFY! Otherwise this won't work correctly with queries.
    
      snapshotDb.create cName, docName,
        type:type.url || type.name
        v:0
        data:type.create initialData
        meta:meta or {}
      , callback # Just passing the error straight through. Should probably sanitize it.
    */

    snapshotDb: snapshotDb,
    getOps: function(cName, docName, from, to, callback) {
      var _ref;
      if (typeof to === 'function') {
        _ref = [-1, to], to = _ref[0], callback = _ref[1];
      }
      if (to == null) {
        to = -1;
      }
      if (to >= 0) {
        if (from >= to) {
          return typeof callback === "function" ? callback(null, []) : void 0;
        }
        to--;
      }
      if (from == null) {
        return callback('invalid getOps fetch');
      }
      return redis.lrange(getOpLogKey(cName, docName), from, to, function(err, values) {
        var op, ops, value;
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        ops = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = values.length; _i < _len; _i++) {
            value = values[_i];
            op = JSON.parse(value);
            op.v = from++;
            _results.push(op);
          }
          return _results;
        })();
        return callback(null, ops);
      });
    },
    publish: function(channel, data) {
      return redis.publish(prefixChannel(channel), (data ? JSON.stringify(data) : void 0));
    },
    submit: function(cName, docName, opData, callback) {
      var err, preValidate, retry, transformedOps, validate,
        _this = this;
      validate = opData.validate || function(opData, snapshot, callback) {
        return callback();
      };
      preValidate = opData.preValidate || function(opData, snapshot, callback) {
        return callback();
      };
      err = ot.checkOpData(opData);
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      ot.normalize(opData);
      transformedOps = [];
      return (retry = function() {
        return _this.fetch(cName, docName, function(err, snapshot) {
          var trySubmit;
          if (opData.v == null) {
            opData.v = snapshot.v;
          }
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          if (snapshot.v < opData.v) {
            return typeof callback === "function" ? callback('Invalid version') : void 0;
          }
          trySubmit = function() {
            return redisSubmit(cName, docName, opData, function(err, result) {
              var d, old, oldOpData, _i, _len;
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              if (typeof result === 'string') {
                return typeof callback === "function" ? callback(result) : void 0;
              }
              if (result && typeof result === 'object') {
                oldOpData = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = result.length; _i < _len; _i++) {
                    d = result[_i];
                    _results.push(JSON.parse(d));
                  }
                  return _results;
                })();
                for (_i = 0, _len = oldOpData.length; _i < _len; _i++) {
                  old = oldOpData[_i];
                  old.v = opData.v;
                  transformedOps.push(old);
                  err = ot.transform(snapshot.type, opData, old);
                  if (err) {
                    return typeof callback === "function" ? callback(err) : void 0;
                  }
                }
                return retry();
              }
              if (snapshotDb.closed) {
                return typeof callback === "function" ? callback(null, opData.v, transformedOps, snapshot) : void 0;
              }
              return snapshotDb.setSnapshot(cName, docName, snapshot, function(err) {
                var db, name;
                if (err) {
                  return typeof callback === "function" ? callback(err) : void 0;
                }
                for (name in extraDbs) {
                  db = extraDbs[name];
                  if (typeof db.submit === "function") {
                    db.submit(cName, docName, opData, snapshot, _this, function(err) {
                      if (err) {
                        return console.warn("Error updating db " + db.name + " " + cName + "." + docName + " with new snapshot data: ", err);
                      }
                    });
                  }
                }
                opData.docName = docName;
                redis.publish(prefixChannel(cName), JSON.stringify(opData));
                return typeof callback === "function" ? callback(null, opData.v, transformedOps, snapshot) : void 0;
              });
            });
          };
          if (snapshot.v === opData.v) {
            return preValidate(opData, snapshot, function(err) {
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              err = ot.apply(snapshot, opData);
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              return validate(opData, snapshot, function(err) {
                if (err) {
                  return typeof callback === "function" ? callback(err) : void 0;
                }
                return trySubmit();
              });
            });
          } else {
            return trySubmit();
          }
        });
      })();
    },
    _subscribeChannels: function(channels, callback) {
      var channel, channelList, i, onMessage, open, stream, _i, _len;
      stream = new Readable({
        objectMode: true
      });
      stream._read = function() {};
      open = true;
      stream._id = nextStreamId++;
      streams[stream._id] = stream;
      stream.destroy = function() {
        var channel, i, _i, _len;
        if (!open) {
          return;
        }
        stream.push(null);
        open = false;
        delete streams[stream._id];
        if (Array.isArray(channels)) {
          for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
            channel = channels[i];
            if (--subscribeCounts[channel] > 0) {
              continue;
            }
            redisObserver.unsubscribe(channel);
            delete subscribeCounts[channel];
          }
        } else {
          if (!(--subscribeCounts[channels] > 0)) {
            redisObserver.unsubscribe(channels);
            delete subscribeCounts[channels];
          }
        }
        redisObserver.removeListener('message', onMessage);
        stream.emit('close');
        return stream.emit('end');
      };
      if (Array.isArray(channels)) {
        for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
          channel = channels[i];
          channel = channels[i] = prefixChannel(channel);
          subscribeCounts[channel] = (subscribeCounts[channel] || 0) + 1;
        }
        onMessage = function(msgChannel, msg) {
          var data;
          if (!open || channels.indexOf(msgChannel) === -1) {
            return;
          }
          data = JSON.parse(msg);
          data.channel = msgChannel.slice(msgChannel.indexOf(' ') + 1);
          return stream.push(data);
        };
        channelList = channels;
      } else {
        channels = prefixChannel(channels);
        subscribeCounts[channels] = (subscribeCounts[channels] || 0) + 1;
        onMessage = function(msgChannel, msg) {
          var data;
          if (!open || msgChannel !== channels) {
            return;
          }
          data = JSON.parse(msg);
          return stream.push(data);
        };
        channelList = [channels];
      }
      redisObserver.on('message', onMessage);
      return redisObserver.subscribe.apply(redisObserver, __slice.call(channelList).concat([function(err) {
        if (err) {
          stream.destroy();
          return callback(err);
        }
        return callback(null, stream);
      }]));
    },
    subscribe: function(cName, docName, v, callback) {
      var opChannel,
        _this = this;
      opChannel = getDocOpChannel(cName, docName);
      return this._subscribeChannels(opChannel, function(err, stream) {
        if (err) {
          callback(err);
        }
        return _this.getOps(cName, docName, v, function(err, data) {
          var d, queue, _i, _j, _len, _len1, _results;
          if (err) {
            stream.destroy();
            return callback(err);
          }
          queue = ((function() {
            var _results;
            _results = [];
            while (d = stream.read()) {
              _results.push(d);
            }
            return _results;
          })());
          callback(null, stream);
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            d = data[_i];
            assert(d.v === v);
            v++;
            stream.push(d);
          }
          _results = [];
          for (_j = 0, _len1 = queue.length; _j < _len1; _j++) {
            d = queue[_j];
            if (!(d.v >= v)) {
              continue;
            }
            assert(d.v === v);
            v++;
            _results.push(stream.push(d));
          }
          return _results;
        });
      });
    },
    fetch: function(cName, docName, callback) {
      var _this = this;
      return snapshotDb.getSnapshot(cName, docName, function(err, snapshot) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        if (snapshot == null) {
          snapshot = {
            v: 0
          };
        }
        if (snapshot.v == null) {
          return callback('Invalid snapshot data');
        }
        return _this.getOps(cName, docName, snapshot.v, function(err, opData) {
          var d, _i, _len;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          for (_i = 0, _len = opData.length; _i < _len; _i++) {
            d = opData[_i];
            err = ot.apply(snapshot, d);
          }
          return callback(err, snapshot);
        });
      });
    },
    fetchAndSubscribe: function(cName, docName, callback) {
      var _this = this;
      return this.fetch(cName, docName, function(err, data) {
        if (err) {
          return callback(err);
        }
        return _this.subscribe(cName, docName, data.v, function(err, stream) {
          return callback(err, data, stream);
        });
      });
    },
    queryFetch: function(cName, query, opts, callback) {
      var db, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else {
        db = snapshotDb;
      }
      return db.query(this, cName, query, function(err, resultset) {
        if (err) {
          return callback(err);
        } else if (Array.isArray(resultset)) {
          return callback(null, resultset);
        } else {
          return callback(null, resultset.results, resultset.extra);
        }
      });
    },
    query: function(index, query, opts, callback) {
      var channels, db, poll, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else {
        db = snapshotDb;
      }
      poll = !db.queryDoc ? true : opts.poll === void 0 && db.queryNeedsPollMode ? db.queryNeedsPollMode(query) : opts.poll;
      channels = db.subscribedChannels ? db.subscribedChannels(index, query, opts) : [index];
      return this._subscribeChannels(channels, function(err, stream) {
        if (err) {
          return callback(err);
        }
        return db.query(_this, index, query, function(err, resultset) {
          var d, docIdx, emitter, extra, f, i, results, _i, _len;
          if (err) {
            stream.destroy();
            return callback(err);
          }
          emitter = new EventEmitter;
          emitter.destroy = function() {
            return stream.destroy();
          };
          if (!Array.isArray(resultset)) {
            emitter.extra = extra = resultset.extra;
            results = resultset.results;
          } else {
            results = resultset;
          }
          emitter.data = results;
          docIdx = {};
          for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
            d = results[i];
            d.c || (d.c = index);
            docIdx["" + d.c + "." + d.docName] = i;
          }
          (f = function() {
            var _results;
            _results = [];
            while (d = stream.read()) {
              _results.push((function(d) {
                var cachedData, modifies;
                d.c = d.channel;
                cachedData = results[docIdx["" + d.c + "." + d.docName]];
                if (cachedData && cachedData.v > d.v) {
                  return;
                }
                modifies = void 0;
                if (modifies === void 0) {
                  if (poll) {
                    return db.query(client, index, query, function(err, newResultset) {
                      var diff, newResults, r, _j, _k, _len1, _len2;
                      if (err) {
                        return emitter.emit('error', new Error(err));
                      }
                      if (!Array.isArray(newResultset)) {
                        if (newResultset.extra) {
                          if (!deepEquals(extra, newResultset.extra)) {
                            emitter.emit('extra', newResultset.extra);
                            emitter.extra = extra = newResultset.extra;
                          }
                        }
                        newResults = newResultset.results;
                      } else {
                        newResults = newResultset;
                      }
                      for (_j = 0, _len1 = newResults.length; _j < _len1; _j++) {
                        r = newResults[_j];
                        r.c || (r.c = index);
                      }
                      diff = arraydiff(results, newResults, function(a, b) {
                        if (!(a && b)) {
                          console.log('####### undefined stuffs');
                          console.log(results);
                          console.log(newResults);
                        }
                        if (!(a && b)) {
                          return false;
                        }
                        return a.docName === b.docName && a.c === b.c;
                      });
                      if (diff.length) {
                        emitter.data = results = newResults;
                        for (_k = 0, _len2 = diff.length; _k < _len2; _k++) {
                          d = diff[_k];
                          d.type = d.type;
                        }
                        return emitter.emit('diff', diff);
                      }
                    });
                  } else {
                    return db.queryDoc(client, index, d.c, d.docName, query, function(err, result) {
                      var idx, name, r, _results1;
                      if (err) {
                        return emitter.emit('error', new Error(err));
                      }
                      if (result && !cachedData) {
                        result.c = d.c;
                        results.push(result);
                        emitter.emit('diff', [
                          {
                            type: 'insert',
                            index: results.length - 1,
                            values: [result]
                          }
                        ]);
                        return docIdx["" + result.c + "." + result.docName] = results.length - 1;
                      } else if (!result && cachedData) {
                        name = "" + d.c + "." + d.docName;
                        idx = docIdx[name];
                        delete docIdx[name];
                        emitter.emit('diff', [
                          {
                            type: 'remove',
                            index: idx,
                            howMany: 1
                          }
                        ]);
                        results.splice(idx, 1);
                        _results1 = [];
                        while (idx < results.length) {
                          r = results[idx++];
                          name = "" + r.c + "." + r.docName;
                          _results1.push(docIdx[name]--);
                        }
                        return _results1;
                      }
                    });
                  }
                }
              })(d));
            }
            return _results;
          })();
          stream.on('readable', f);
          return callback(null, emitter);
        });
      });
    },
    collection: function(cName) {
      return {
        submit: function(docName, opData, callback) {
          return client.submit(cName, docName, opData, callback);
        },
        subscribe: function(docName, v, callback) {
          return client.subscribe(cName, docName, v, callback);
        },
        getOps: function(docName, from, to, callback) {
          return client.getOps(cName, docName, from, to, callback);
        },
        fetch: function(docName, callback) {
          return client.fetch(cName, docName, callback);
        },
        fetchAndObserve: function(docName, callback) {
          return client.fetchAndObserve(cName, docName, callback);
        },
        queryFetch: function(query, opts, callback) {
          return client.queryFetch(cName, query, opts, callback);
        },
        query: function(query, opts, callback) {
          return client.query(cName, query, opts, callback);
        }
      };
    },
    destroy: function() {
      var id, s, _results;
      redis.quit();
      _results = [];
      for (id in streams) {
        s = streams[id];
        _results.push(s.destroy());
      }
      return _results;
    }
  };
};
