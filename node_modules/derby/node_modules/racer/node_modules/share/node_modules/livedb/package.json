{
  "name": "livedb",
  "version": "0.3.0",
  "description": "Realtime database wrapper",
  "main": "lib/index.js",
  "dependencies": {
    "redis": "~0.8",
    "ottypes": "~1",
    "deep-is": "~0.1",
    "arraydiff": "~0.1",
    "hiredis": "~0.1",
    "statsd-client": "*"
  },
  "optionalDependencies": {
    "hiredis": "~0.1",
    "statsd-client": "*"
  },
  "devDependencies": {
    "mocha": "~1",
    "sinon": "~1",
    "coffee-script": "*"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/share/livedb.git"
  },
  "author": {
    "name": "Joseph Gentle",
    "email": "josephg@gmail.com"
  },
  "license": "MIT",
  "gitHead": "a95ee727e5cb43a40476f58554774b776fb08f68",
  "readme": "# LIVE DB!\n\nThis is a database wrapper which exposes the API that realtime databases should\nhave.\n\nYou can submit operations (edit documents) and subscribe to documents.\nSubscribing gives you a stream of all operations applied to the given\ndocument. You can also make queries, which give you a feed of changes in the\nresult set while the query is open.\n\nCurrently this is very new and only used by ShareJS. To use it, you need a\nsnapshot database wrapper. The obvious choice is mongodb. A database wrapper\nfor mongo is available in\n[share/livedb-mongo](https://github.com/share/livedb-mongo).\n\n\n## Data Model\n\nIn LiveDB's view of the world, every document has 3 properties:\n\n- **version**: an incrementing number starting at 0\n- **type**: an OT type. OT types are defined in\n[share/ottypes](https://github.com/share/ottypes). Types are referenced using\ntheir URIs (even though those URIs don't actually mean anything). Documents\nwhich don't exist implicitly have a type of `null`.\n- **data**: The actual data that the document contains. This must be pure\nacyclic JSON. Its also type-specific. (JSON type uses raw JSON, text documents\nuse a string, etc).\n\nLiveDB implicitly has a record for every document you can access. New documents\nhave version 0, a null type and no data. To use a document, you must first\nsubmit a *create operation*, which will set the document's type and give it\ninitial data. Then you can submit editing operations on the document (using\nOT). Finally you can delete the document with a delete operation. By\ndefault, livedb stores all operations forever - nothing is truly deleted.\n\n\n## Using Livedb\n\nLivedb requires a backend database to store snapshots & operations. You can put snapshots & operations in different places if you want, though its easier to put all data in the same place.\n\nThe backend database(s) needs to implement a [simple API which has documentation and a sample implementation here](https://github.com/share/livedb/blob/master/lib/memory.js). Currently the only database binding is [livedb-mongo](https://github.com/share/livedb-mongo).\n\nA livedb client is created using either an options object or a database backend. If you specify a database backend, its used as both oplog and snapshot.\n\n```javascript\ndb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\nlivedb = require('livedb').client(db);\n```\n\nOr using an options object:\n\n```\ndb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\nlivedb = require('livedb').client({db:db});\n```\n\nYou can use a different database for both snapshots and operations:\n\n```\nsnapshotdb = require('livedb-mongo')('localhost:27017/test?auto_reconnect', {safe:true});\noplog = {writeOp:..., getVersion:..., getOps:...};\nlivedb = require('livedb').client({snapshotDb:snapshotdb, oplog:oplog});\n```\n\n\n`client({db:db});` is a shorthand for `client({snapshotDb:db, oplog:db})`.\n\nThe options object can also be passed:\n\n- **redis:** *redis client*. This can be specified if there is any further\n    configuration of redis that you want to perform. The obvious examples of\n    this are when redis is running on a remote machine, redis requires\n    authentication or you want to use something other than redis db 0.\n- **redisObserver:** *redis client*. Livedb actually needs 2 redis connections,\n    because redis doesn't let you use a connection with pubsub subscriptions\n    to edit data. Livedb will automatically try to clone the first connection\n    to make the observer connection, but we can't copy some options. if you\n    want to do anything thats particularly fancy, you should make 2 redis\n    instances and provide livedb with both of them. Note that because redis\n    pubsub messages aren't constrained to the selected database, the\n    redisObserver doesn't need to select the db you have your data in.\n- **extraDbs:** *{name:query db}* This is used to register extra database backends which will be\n    notified whenever operations are submitted. They can also be used in\n    queries.\n\n\n### Creating documents\n\nTo create a document, you first need to submit a create operation to the\ndocument to set its type. A document doesn't properly exist until it has a type\n--- it certainly can't store any data.\n\nA create operation looks like this: `{create:{type:TYPE, [data:INITIAL DATA]}, [v:VERSION]}`. The type should be something accessible in the map returned by require('ottypes'), for example `json0` or `http://sharejs.org/types/textv1`. Specifying initial data is optional. If provided, it is passed to the type's `create()` method. This does what you expect - for JSON documents, pass your initial object here. For text documents, pass a string containing the document's contents. As with all operations, the version is optional. You probably don't want to specify the version for a create message.\n\nFor example:\n\n```javascript\nlivedb.submit('users', 'fred', {create:{type:'json0', data:[1,2,3]}}, function(err, version, transformedByOps, snapshot) {\n  // I made a document, ma!\n});\n```\n\nSince documents implicitly exist with no type at version 0, usually the create message will increment the version from 0 to 1. Not all documents you want to delete have a version of 0 - if a document is deleted, it will retain its version.\n\n### Deleting documents\n\nDeleting documents is similar to creating them. A deleted document has no type and no data, but will retain its version (actually, the delete operation will bump the document's version). A delete operation looks like this: `{del:true, [v:VERSION]}`.\n\n```javascript\nlivedb.submit('users', 'fred', {del:true}, function(err) {\n  //goneskies! Kapow!\n});\n```\n\n### Editing documents\n\nYou edit a document by submitting an operation. Operations are OT type-specific JSON blobs. Refer to the documentation on the particular OT type for details. For example, text documents are documented [here](https://github.com/share/ottypes/blob/master/lib/text.js#L10-L16). If we had a text document stored in LiveDB and wanted to edit it, it might look like this:\n\n```javascript\nlivedb.submit('love letters', 'dear fred', {op:[6, \"You never return my calls!\"], v:1002}, function(err) {\n  // ...\n});\n```\n\nYou should always specify the version when submitting operations. If you don't, operations will do funny things in the face of concurrency.\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/share/livedb/issues"
  },
  "homepage": "https://github.com/share/livedb",
  "_id": "livedb@0.3.0",
  "_from": "livedb@>=0.2.3"
}
