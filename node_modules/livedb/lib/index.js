// Generated by CoffeeScript 1.6.3
var EventEmitter, Readable, arraydiff, assert, deepEquals, isError, ot, rateLimit, redisLib;

Readable = require('stream').Readable;

EventEmitter = require('events').EventEmitter;

assert = require('assert');

isError = require('util').isError;

deepEquals = require('deep-is');

redisLib = require('redis');

arraydiff = require('arraydiff');

ot = require('./ot');

rateLimit = require('./ratelimit');

exports.memory = require('./memory');

exports.client = function(options) {
  var addStream, atomicSubmit, bulkGetOpsSince, client, extraDbs, getDocOpChannel, getOpLogKey, getOps, getVersionKey, logEntryForData, nextStreamId, oplog, oplogGetOps, packOpStream, prefixChannel, processRedisOps, redis, redisAddChannelListeners, redisCacheVersion, redisGetOps, redisObserver, redisRemoveChannelListeners, redisSetExpire, redisSubmitScript, removeStream, snapshotDb, streams, subscribers, writeOpToLog;
  snapshotDb = options.snapshotDb || options.db || options;
  if (!(snapshotDb.getSnapshot && snapshotDb.writeSnapshot)) {
    throw new Error('Missing or invalid snapshot db');
  }
  oplog = options.oplog || options.db || options;
  if (!(oplog.writeOp && oplog.getVersion && oplog.getOps)) {
    throw new Error('Missing or invalid operation log');
  }
  redis = options.redis || redisLib.createClient();
  redisObserver = options.redisObserver;
  if (!redisObserver) {
    redisObserver = redisLib.createClient(redis.port, redis.host, redis.options);
    if (redis.auth_pass) {
      redisObserver.auth(redis.auth_pass);
    }
  }
  redisObserver.setMaxListeners(0);
  extraDbs = options.extraDbs || {};
  streams = {};
  nextStreamId = 0;
  addStream = function(stream) {
    stream._id = nextStreamId++;
    return streams[stream._id] = stream;
  };
  removeStream = function(stream) {
    return delete streams[stream._id];
  };
  subscribers = new EventEmitter();
  redisObserver.on('message', function(channel, msg) {
    return subscribers.emit(channel, channel, JSON.parse(msg));
  });
  prefixChannel = function(channel) {
    return "" + (redis.selected_db || 0) + " " + channel;
  };
  getVersionKey = function(cName, docName) {
    return "" + cName + "." + docName + " v";
  };
  getOpLogKey = function(cName, docName) {
    return "" + cName + "." + docName + " ops";
  };
  getDocOpChannel = function(cName, docName) {
    return "" + cName + "." + docName;
  };
  processRedisOps = function(docV, to, result) {
    var op, v, value, _i, _len, _results;
    v = to === -1 ? docV - result.length : to - result.length + 1;
    _results = [];
    for (_i = 0, _len = result.length; _i < _len; _i++) {
      value = result[_i];
      op = JSON.parse(value);
      op.v = v++;
      _results.push(op);
    }
    return _results;
  };
  logEntryForData = function(opData) {
    var entry;
    entry = {};
    if (opData.src) {
      entry.src = opData.src;
    }
    if (opData.seq) {
      entry.seq = opData.seq;
    }
    if (opData.op) {
      entry.op = opData.op;
    } else if (opData.del) {
      entry.del = opData.del;
    } else if (opData.create) {
      entry.create = opData.create;
    }
    entry.m = opData.m;
    return entry;
  };
  redisSubmitScript = function(cName, docName, opData, docVersion, callback) {
    var docPubEntry, logEntry;
    logEntry = JSON.stringify(logEntryForData(opData));
    docPubEntry = JSON.stringify(opData);
    return redis["eval"]("local clientNonceKey, versionKey, opLogKey, docOpChannel = unpack(KEYS)\nlocal seq, v, logEntry, docPubEntry, docVersion = unpack(ARGV) -- From redisSubmit, below.\nv = tonumber(v)\nseq = tonumber(seq)\ndocVersion = tonumber(docVersion)\n\n-- Check the version matches.\nif docVersion ~= nil then\n  -- setnx returns true if we set the value.\n  if redis.call('setnx', versionKey, docVersion) == 0 then\n    docVersion = tonumber(redis.call('get', versionKey))\n  else\n    -- We've just set the version ourselves. Wipe any junk in the oplog.\n    redis.call('del', opLogKey)\n  end\nelse\n  docVersion = tonumber(redis.call('get', versionKey))\nend\n\nif docVersion == nil then\n  -- This is not an error - it will happen whenever the TTL expires or redis is wiped.\n  return \"Missing data\"\nend\n\n\nif v < docVersion then\n  -- The operation needs transformation. I could short-circuit here for\n  -- performance and return any ops in redis, but livedb logic is simpler if I\n  -- simply punt to getOps() below, and I don't think its a bottleneck.\n  return \"Transform needed\"\n  --local ops = redis.call('lrange', opLogKey, -(docVersion - v), -1) \n  --ops[#ops + 1] = docVersion\n  --return ops\nelseif v > docVersion then\n  -- Redis's version is older than the snapshot database. We might just be out\n  -- of date, though it should be mostly impossible to get into this state.\n  -- We'll dump all our data and expect to be refilled from whatever is in the\n  -- persistant oplog.\n  redis.call('del', versionKey)\n  return \"Version from the future\"\nend\n\n-- Dedup, but only if the id has been set.\nif seq ~= nil then\n  local nonce = redis.call('GET', clientNonceKey)\n  if nonce ~= false and tonumber(nonce) >= seq then\n    return \"Op already submitted\"\n  end\nend\n\n-- Ok to submit. Save the op in the oplog and publish.\nredis.call('rpush', opLogKey, logEntry)\nredis.call('set', versionKey, v + 1)\n\nredis.call('persist', opLogKey)\nredis.call('persist', versionKey)\n\nredis.call('publish', docOpChannel, docPubEntry)\n\n-- Finally, save the new nonce. We do this here so we only update the nonce if\n-- we're at the most recent version in the oplog.\nif seq ~= nil then\n  --redis.log(redis.LOG_NOTICE, \"set \" .. clientNonceKey .. \" to \" .. seq)\n  redis.call('SET', clientNonceKey, seq)\n  redis.call('EXPIRE', clientNonceKey, 60*60*24*7) -- 1 week\nend", 4, opData.src, getVersionKey(cName, docName), getOpLogKey(cName, docName), prefixChannel(getDocOpChannel(cName, docName)), opData.seq, opData.v, logEntry, docPubEntry, docVersion, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(err, result);
    });
  };
  atomicSubmit = function(cName, docName, opData, callback) {
    return redisSubmitScript(cName, docName, opData, null, function(err, result) {
      if (err) {
        return callback(err);
      }
      if (result === 'Missing data' || result === 'Version from the future') {
        return oplog.getVersion(cName, docName, function(err, version) {
          if (err) {
            return callback(err);
          }
          if (version < opData.v) {
            throw Error("Missing oplog for " + cName + " " + docName);
          }
          return redisSubmitScript(cName, docName, opData, version, callback);
        });
      } else {
        return callback(null, result);
      }
    });
  };
  redisGetOps = function(cName, docName, from, to, callback) {
    if (to == null) {
      to = -1;
    }
    if (to >= 0) {
      if (from >= to || to === 0) {
        return callback(null, null, []);
      }
      to--;
    }
    return redis["eval"]("local versionKey, opLogKey = unpack(KEYS)\nlocal from = tonumber(ARGV[1])\nlocal to = tonumber(ARGV[2])\n\nlocal v = tonumber(redis.call('get', versionKey))\n\n-- We're asking for ops the server doesn't have.\nif v == nil then return nil end\nif from >= v then return {v} end\n\n--redis.log(redis.LOG_NOTICE, \"v \" .. tostring(v) .. \" from \" .. from .. \" to \" .. to)\nif to >= 0 then\n  to = to - v\nend\nfrom = from - v\n\nlocal ops = redis.call('lrange', opLogKey, from, to)\nops[#ops+1] = v -- We'll put the version of the document at the end.\nreturn ops", 2, getVersionKey(cName, docName), getOpLogKey(cName, docName), from, to, function(err, result) {
      var docV, ops;
      if (err) {
        return callback(err);
      }
      if (result === null) {
        return callback(null, null, []);
      }
      docV = result.pop();
      ops = processRedisOps(docV, to, result);
      return callback(null, docV, ops);
    });
  };
  redisSetExpire = function(cName, docName, v, callback) {
    return redis["eval"]("local versionKey, opLogKey = unpack(KEYS)\nlocal v = unpack(ARGV)\n\nv = tonumber(v)\n\n-- Check the version matches.\nlocal realv = tonumber(redis.call('get', versionKey))\n\nif v == realv - 1 then\n  redis.call('expire', versionKey, 60*60*24) -- 1 day\n  redis.call('expire', opLogKey, 60*60*24) -- 1 day\n  redis.call('ltrim', opLogKey, -100, -1) -- Only 100 ops, counted from the end.\n   \n  --redis.call('del', versionKey)\n  --redis.call('del', opLogKey)\n  --redis.call('del', opLogKey)\n\n  -- Doing this directly for now. I don't know the performance impact, but its cleaner.\n  --redis.call('PUBLISH', publishChannel, opData)\nend", 2, getVersionKey(cName, docName), getOpLogKey(cName, docName), v, callback);
  };
  redisCacheVersion = function(cName, docName, v, callback) {
    return redis.setnx(getVersionKey(cName, docName), v, function(err, didSet) {
      if (err || !didSet) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      redis.del(getOpLogKey(cName, docName));
      return redisSetExpire(cName, docName, v, callback);
    });
  };
  oplogGetOps = function(cName, docName, from, to, callback) {
    return oplog.getOps(cName, docName, from, to, function(err, ops) {
      var op, _i, _len;
      if (err) {
        return callback(err);
      }
      if (ops.length && ops[0].v !== from) {
        throw new Error('Oplog is returning incorrect ops');
      }
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        op.v = from++;
      }
      return callback(null, ops);
    });
  };
  getOps = function(cName, docName, from, to, callback) {
    return redisGetOps(cName, docName, from, to, function(err, v, ops) {
      if (err) {
        return callback(err);
      }
      if (((v != null) && from >= v) || (ops.length > 0 && ops[0].v === from)) {
        return callback(null, ops);
      } else if (ops.length > 0) {
        return oplogGetOps(cName, docName, from, ops[0].v, function(err, firstOps) {
          if (err) {
            return callback(err);
          }
          return callback(null, firstOps.concat(ops));
        });
      } else {
        return oplogGetOps(cName, docName, from, to, function(err, ops) {
          if (err) {
            return callback(err);
          }
          if ((v == null) && (to == null)) {
            oplog.getVersion(cName, docName, function(err, version) {
              if (err) {
                return;
              }
              return redisCacheVersion(cName, docName, version);
            });
          }
          return callback(null, ops);
        });
      }
    });
  };
  bulkGetOpsSince = function(requests, callback) {
    var cName, cNames, data, docName, docNames, froms, redisArgs, version;
    cNames = [];
    docNames = [];
    redisArgs = ["-- We'll preserve order in the results.\nlocal results = {}\n\nfor i=1,#KEYS,2 do\n  local versionKey = KEYS[i]\n  local opLogKey = KEYS[i+1]\n  local from = tonumber(ARGV[(i+1)/2])\n\n  local v = tonumber(redis.call('get', versionKey))\n\n  if v == nil then\n    -- We're asking for ops that redis doesn't have. Have to get them from the oplog.\n    results[#results+1] = 0 -- A nil in a lua table doesn't have the semantics I need.\n  elseif from >= v then\n    -- Most common case. There's no ops, get over it & move on with your life.\n    results[#results+1] = {}\n  else\n    local numExpected = v - from\n    from = from - v\n    local ops = redis.call('lrange', opLogKey, from, -1)\n    if #ops ~= numExpected then\n      results[#results+1] = 0 -- Punt back to the oplog for the ops themselves.\n    else\n      results[#results+1] = ops\n    end\n  end\nend\n\nreturn results", 0];
    froms = [];
    for (cName in requests) {
      data = requests[cName];
      for (docName in data) {
        version = data[docName];
        cNames.push(cName);
        docNames.push(docName);
        redisArgs.push(getVersionKey(cName, docName));
        redisArgs.push(getOpLogKey(cName, docName));
        froms.push(version);
      }
    }
    redisArgs[1] = redisArgs.length - 2;
    redisArgs = redisArgs.concat(froms);
    return redis["eval"](redisArgs, function(err, redisResults) {
      var done, from, i, op, ops, pending, result, results, v, value, _i, _len, _name;
      if (err) {
        return callback(err);
      }
      if (redisResults.length !== cNames.length) {
        return callback('Invalid data from redis');
      }
      results = {};
      pending = 1;
      done = function() {
        pending--;
        if (pending === 0) {
          return callback(null, results);
        }
      };
      for (i = _i = 0, _len = redisResults.length; _i < _len; i = ++_i) {
        result = redisResults[i];
        if (results[_name = cNames[i]] == null) {
          results[_name] = {};
        }
        cName = cNames[i];
        docName = docNames[i];
        from = froms[i];
        if (result === 0) {
          pending++;
          (function(cName, docName, from) {
            return oplogGetOps(cName, docName, from, null, function(err, ops) {
              if (err) {
                return callback(err);
              }
              results[cName][docName] = ops;
              version = from + ops.length;
              return redisCacheVersion(cName, docName, version, done);
            });
          })(cName, docName, from);
        } else {
          v = from;
          ops = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
              value = result[_j];
              op = JSON.parse(value);
              op.v = v++;
              _results.push(op);
            }
            return _results;
          })();
          results[cName][docName] = ops;
        }
      }
      return done();
    });
  };
  writeOpToLog = function(cName, docName, opData, callback) {
    var entry;
    entry = logEntryForData(opData);
    entry.v = opData.v;
    return oplog.getVersion(cName, docName, function(err, version) {
      var _this = this;
      if (err) {
        return callback(err);
      }
      if (version < opData.v) {
        console.log('populating oplog', version, opData.v);
        return redisGetOps(cName, docName, version, opData.v, function(err, docV, results) {
          var f;
          if (err) {
            return callback(err);
          }
          results.push(entry);
          return (f = function() {
            if (results.length === 0) {
              return callback();
            }
            return oplog.writeOp(cName, docName, results.shift(), function(err) {
              if (err) {
                return callback(err);
              }
              return process.nextTick(f);
            });
          })();
        });
      } else if (version === opData.v) {
        return oplog.writeOp(cName, docName, entry, function(err) {
          return callback(err);
        });
      }
    });
  };
  if (snapshotDb.bulkGetSnapshot == null) {
    snapshotDb.bulkGetSnapshot = function(requests, callback) {
      var cName, cResults, docName, docs, done, pending, results, _fn, _i, _len;
      results = {};
      pending = 1;
      done = function() {
        pending--;
        if (pending === 0) {
          return callback(null, results);
        }
      };
      for (cName in requests) {
        docs = requests[cName];
        cResults = results[cName] = {};
        pending += docs.length;
        _fn = function(cResults, docName) {
          return snapshotDb.getSnapshot(cName, docName, function(err, data) {
            if (err) {
              return callback(err);
            }
            if (data) {
              cResults[docName] = data;
            }
            return done();
          });
        };
        for (_i = 0, _len = docs.length; _i < _len; _i++) {
          docName = docs[_i];
          _fn(cResults, docName);
        }
      }
      return done();
    };
  }
  redisAddChannelListeners = function(channels, listeners, callback) {
    var channel, i, listener, needsSubscribe, _i, _len;
    if (!Array.isArray(channels)) {
      channels = [channels];
    }
    if (Array.isArray(listeners)) {
      assert(listeners.length === channels.length);
    }
    needsSubscribe = [];
    for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
      channel = channels[i];
      channel = prefixChannel(channel);
      listener = listeners[i] || listeners;
      if (EventEmitter.listenerCount(subscribers, channel) === 0) {
        needsSubscribe.push(channel);
      }
      subscribers.on(channel, listener);
    }
    if (needsSubscribe.length > 0) {
      return redisObserver.subscribe(needsSubscribe, callback);
    } else {
      return typeof callback === "function" ? callback() : void 0;
    }
  };
  redisRemoveChannelListeners = function(channels, listeners, callback) {
    var channel, i, listener, needsUnSubscribe, _i, _len;
    if (!Array.isArray(channels)) {
      channels = [channels];
    }
    if (Array.isArray(listeners)) {
      assert(listeners.length === channels.length);
    }
    needsUnSubscribe = [];
    for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
      channel = channels[i];
      channel = prefixChannel(channel);
      listener = listeners[i] || listeners;
      subscribers.removeListener(channel, listener);
      if (EventEmitter.listenerCount(subscribers, channel) === 0) {
        needsUnSubscribe.push(channel);
      }
    }
    if (needsUnSubscribe.length > 0) {
      return redisObserver.unsubscribe(needsUnSubscribe, callback);
    } else {
      return typeof callback === "function" ? callback() : void 0;
    }
  };
  packOpStream = function(v, stream, ops) {
    var d, queue, _i, _j, _len, _len1, _results;
    queue = ((function() {
      var _results;
      _results = [];
      while (d = stream.read()) {
        _results.push(d);
      }
      return _results;
    })());
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      d = ops[_i];
      assert.equal(d.v, v);
      v++;
      stream.push(d);
    }
    _results = [];
    for (_j = 0, _len1 = queue.length; _j < _len1; _j++) {
      d = queue[_j];
      if (!(d.v >= v)) {
        continue;
      }
      assert.equal(d.v, v);
      v++;
      _results.push(stream.push(d));
    }
    return _results;
  };
  return client = {
    snapshotDb: snapshotDb,
    oplog: oplog,
    getOps: function(cName, docName, from, to, callback) {
      var _ref;
      if (typeof to === 'function') {
        _ref = [null, to], to = _ref[0], callback = _ref[1];
      }
      if (to >= 0) {
        if ((to != null) && from > to) {
          return callback(null, []);
        }
      }
      if (from == null) {
        return callback('Invalid from field in getOps');
      }
      return getOps(cName, docName, from, to, callback);
    },
    publish: function(channel, data) {
      return redis.publish(prefixChannel(channel), (data ? JSON.stringify(data) : void 0));
    },
    submit: function(cName, docName, opData, options, callback) {
      var err, retry, transformedOps, _ref,
        _this = this;
      if (typeof options === 'function') {
        _ref = [{}, options], options = _ref[0], callback = _ref[1];
      }
      if (options == null) {
        options = {};
      }
      err = ot.checkOpData(opData);
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      ot.normalize(opData);
      transformedOps = [];
      return (retry = function() {
        return _this.fetch(cName, docName, function(err, snapshot) {
          var trySubmit;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          if (snapshot.v < opData.v) {
            return typeof callback === "function" ? callback('Invalid version') : void 0;
          }
          if (opData.v == null) {
            opData.v = snapshot.v;
          }
          trySubmit = function() {
            return atomicSubmit(cName, docName, opData, function(err, result) {
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              if (result === 'Transform needed') {
                return getOps(cName, docName, opData.v, null, function(err, ops) {
                  var old, _i, _len;
                  if (err) {
                    return typeof callback === "function" ? callback(err) : void 0;
                  }
                  if (ops.length === 0) {
                    return typeof callback === "function" ? callback('Intermediate operations missing - cannot apply op') : void 0;
                  }
                  for (_i = 0, _len = ops.length; _i < _len; _i++) {
                    old = ops[_i];
                    transformedOps.push(old);
                    err = ot.transform(snapshot.type, opData, old);
                    if (err) {
                      return typeof callback === "function" ? callback(err) : void 0;
                    }
                  }
                  return retry();
                });
              }
              if (typeof result === 'string') {
                return typeof callback === "function" ? callback(result) : void 0;
              }
              return writeOpToLog(cName, docName, opData, function(err) {
                if (err) {
                  return typeof callback === "function" ? callback(err) : void 0;
                }
                return snapshotDb.writeSnapshot(cName, docName, snapshot, function(err) {
                  var db, name;
                  if (err) {
                    return typeof callback === "function" ? callback(err) : void 0;
                  }
                  for (name in extraDbs) {
                    db = extraDbs[name];
                    if (typeof db.submit === "function") {
                      db.submit(cName, docName, opData, options, snapshot, _this, function(err) {
                        if (err) {
                          return console.warn("Error updating db " + name + " " + cName + "." + docName + " with new snapshot data: ", err);
                        }
                      });
                    }
                  }
                  opData.docName = docName;
                  redis.publish(prefixChannel(cName), JSON.stringify(opData));
                  redisSetExpire(cName, docName, opData.v, function(err) {
                    if (err) {
                      return console.error(err);
                    }
                  });
                  return typeof callback === "function" ? callback(null, opData.v, transformedOps, snapshot) : void 0;
                });
              });
            });
          };
          if (snapshot.v === opData.v) {
            err = ot.apply(snapshot, opData);
            if (err) {
              if (typeof err !== 'string' && !isError(err)) {
                console.warn('INVALID VALIDATION FN!!!!');
                console.warn('Your validation function must return null/undefined, a string or an error object.');
                console.warn('Instead we got', err);
              }
              return typeof callback === "function" ? callback(err) : void 0;
            }
          }
          return trySubmit();
        });
      })();
    },
    _subscribeChannels: function(channels, callback) {
      var listener, open, stream;
      stream = new Readable({
        objectMode: true
      });
      stream._read = function() {};
      open = true;
      addStream(stream);
      stream.destroy = function() {
        if (!open) {
          return;
        }
        stream.push(null);
        open = false;
        removeStream(stream);
        redisRemoveChannelListeners(channels, listener);
        stream.emit('close');
        return stream.emit('end');
      };
      listener = Array.isArray(channels) ? function(msgChannel, data) {
        msgChannel = msgChannel.slice(msgChannel.indexOf(' ') + 1);
        if (!open || channels.indexOf(msgChannel) === -1) {
          return;
        }
        data.channel = msgChannel;
        return stream.push(data);
      } : function(msgChannel, data) {
        if (!open || msgChannel !== prefixChannel(channels)) {
          return;
        }
        return stream.push(data);
      };
      return redisAddChannelListeners(channels, listener, function(err) {
        if (err) {
          stream.destroy();
          return callback(err);
        } else {
          return callback(null, stream);
        }
      });
    },
    subscribe: function(cName, docName, v, callback) {
      var opChannel,
        _this = this;
      opChannel = getDocOpChannel(cName, docName);
      return this._subscribeChannels(opChannel, function(err, stream) {
        if (err) {
          callback(err);
        }
        return _this.getOps(cName, docName, v, function(err, ops) {
          if (err) {
            stream.destroy();
            return callback(err);
          }
          packOpStream(v, stream, ops);
          return callback(null, stream);
        });
      });
    },
    bulkSubscribe: function(requests, callback) {
      var cName, channelName, channels, docName, docStream, docStreams, docs, listener, onError, prefixedName, version;
      docStreams = {};
      channels = [];
      listener = function(channel, msg) {
        var _ref;
        return (_ref = docStreams[channel]) != null ? _ref.push(msg) : void 0;
      };
      for (cName in requests) {
        docs = requests[cName];
        for (docName in docs) {
          version = docs[docName];
          channelName = getDocOpChannel(cName, docName);
          prefixedName = prefixChannel(channelName);
          channels.push(channelName);
          docStream = docStreams[prefixedName] = new Readable({
            objectMode: true
          });
          docStream._read = function() {};
          docStream.channelName = channelName;
          docStream.prefixedName = prefixedName;
          docStream.destroy = function() {
            removeStream(docStream);
            delete docStreams[this.prefixedName];
            return redisRemoveChannelListeners(this.channelName, listener);
          };
          addStream(docStream);
        }
      }
      onError = function(err) {
        var channel, s;
        for (channel in docStreams) {
          s = docStreams[channel];
          s.destroy();
        }
        return callback(err);
      };
      return redisAddChannelListeners(channels, listener, function(err) {
        var _this = this;
        if (err) {
          return onError(err);
        }
        return bulkGetOpsSince(requests, function(err, ops) {
          var result, stream;
          if (err) {
            return onError(err);
          }
          result = {};
          for (cName in requests) {
            docs = requests[cName];
            result[cName] = {};
            for (docName in docs) {
              version = docs[docName];
              channelName = getDocOpChannel(cName, docName);
              prefixedName = prefixChannel(channelName);
              stream = result[cName][docName] = docStreams[prefixedName];
              packOpStream(version, stream, ops[cName][docName]);
            }
          }
          return callback(null, result);
        });
      });
    },
    fetch: function(cName, docName, callback) {
      var _this = this;
      return snapshotDb.getSnapshot(cName, docName, function(err, snapshot) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        if (snapshot == null) {
          snapshot = {
            v: 0
          };
        }
        if (snapshot.v == null) {
          return callback('Invalid snapshot data');
        }
        return client.getOps(cName, docName, snapshot.v, function(err, results) {
          var opData, _i, _len;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            opData = results[_i];
            err = ot.apply(snapshot, opData);
          }
          return redisCacheVersion(cName, docName, snapshot.v, function() {
            return callback(null, snapshot);
          });
        });
      });
    },
    bulkFetch: function(requests, callback) {
      return snapshotDb.bulkGetSnapshot(requests, function(err, results) {
        var cName, docName, docs, _base, _i, _len;
        if (err) {
          return callback(err);
        }
        for (cName in requests) {
          docs = requests[cName];
          for (_i = 0, _len = docs.length; _i < _len; _i++) {
            docName = docs[_i];
            if ((_base = results[cName])[docName] == null) {
              _base[docName] = {
                v: 0
              };
            }
          }
        }
        return callback(null, results);
      });
    },
    bulkFetchCached: function(cName, docNames, callback) {
      var abort, docName, i, pending, results, _fn, _i, _len,
        _this = this;
      if (snapshotDb.getBulkSnapshots) {
        return snapshotDb.getBulkSnapshots(cName, docNames, function(err, results) {
          var docName, list, map, r, _i, _len;
          if (err) {
            return callback(err);
          }
          map = {};
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            r = results[_i];
            map[r.docName] = r;
          }
          list = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = docNames.length; _j < _len1; _j++) {
              docName = docNames[_j];
              _results.push(map[docName] || {
                v: 0
              });
            }
            return _results;
          })();
          return callback(null, list);
        });
      } else {
        results = new Array(docNames.length);
        pending = docNames.length + 1;
        abort = false;
        _fn = function(i) {
          return _this.fetch(cName, docName, function(err, data) {
            if (abort) {
              return;
            }
            if (err) {
              abort = true;
              return callback(err);
            }
            results[i] = data;
            pending--;
            if (pending === 0) {
              return callback(results);
            }
          });
        };
        for (i = _i = 0, _len = docNames.length; _i < _len; i = ++_i) {
          docName = docNames[i];
          _fn(i);
        }
        pending--;
        if (pending === 0) {
          return callback(results);
        }
      }
    },
    fetchAndSubscribe: function(cName, docName, callback) {
      var _this = this;
      return this.fetch(cName, docName, function(err, data) {
        if (err) {
          return callback(err);
        }
        return _this.subscribe(cName, docName, data.v, function(err, stream) {
          return callback(err, data, stream);
        });
      });
    },
    queryFetch: function(cName, query, opts, callback) {
      var db, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else {
        db = snapshotDb;
      }
      return db.query(this, cName, query, function(err, resultset) {
        if (err) {
          return callback(err);
        } else if (Array.isArray(resultset)) {
          return callback(null, resultset);
        } else {
          return callback(null, resultset.results, resultset.extra);
        }
      });
    },
    query: function(index, query, opts, callback) {
      var channels, db, delay, poll, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else if (snapshotDb.query) {
        db = snapshotDb;
      } else {
        return callback('Backend not specified and database does not support queries');
      }
      poll = !db.queryDoc ? true : opts.poll === void 0 && db.queryNeedsPollMode ? db.queryNeedsPollMode(index, query) : opts.poll;
      delay = typeof opts.pollDelay === 'number' ? opts.pollDelay : 2000;
      channels = db.subscribedChannels ? db.subscribedChannels(index, query, opts) : [index];
      return this._subscribeChannels(channels, function(err, stream) {
        if (err) {
          return callback(err);
        }
        return db.query(_this, index, query, function(err, resultset) {
          var d, docIdx, emitter, extra, f, i, results, runQuery, _i, _len;
          if (err) {
            stream.destroy();
            return callback(err);
          }
          emitter = new EventEmitter;
          emitter.destroy = function() {
            return stream.destroy();
          };
          if (!Array.isArray(resultset)) {
            emitter.extra = extra = resultset.extra;
            results = resultset.results;
          } else {
            results = resultset;
          }
          emitter.data = results;
          docIdx = {};
          for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
            d = results[i];
            d.c || (d.c = index);
            docIdx["" + d.c + "." + d.docName] = i;
          }
          if (poll) {
            runQuery = rateLimit(delay, function() {
              return db.query(client, index, query, function(err, newResultset) {
                var data, diff, newResults, r, _j, _k, _len1, _len2;
                if (err) {
                  return emitter.emit('error', new Error(err));
                }
                if (!Array.isArray(newResultset)) {
                  if (newResultset.extra !== void 0) {
                    if (!deepEquals(extra, newResultset.extra)) {
                      emitter.emit('extra', newResultset.extra);
                      emitter.extra = extra = newResultset.extra;
                    }
                  }
                  newResults = newResultset.results;
                } else {
                  newResults = newResultset;
                }
                for (_j = 0, _len1 = newResults.length; _j < _len1; _j++) {
                  r = newResults[_j];
                  r.c || (r.c = index);
                }
                diff = arraydiff(results, newResults, function(a, b) {
                  if (!(a && b)) {
                    return false;
                  }
                  return a.docName === b.docName && a.c === b.c;
                });
                if (diff.length) {
                  emitter.data = results = newResults;
                  for (_k = 0, _len2 = diff.length; _k < _len2; _k++) {
                    data = diff[_k];
                    data.type = data.type;
                  }
                  return emitter.emit('diff', diff);
                }
              });
            });
          }
          (f = function() {
            var _results;
            _results = [];
            while (d = stream.read()) {
              _results.push((function(d) {
                var cachedData, modifies;
                d.c = d.channel;
                cachedData = results[docIdx["" + d.c + "." + d.docName]];
                if (cachedData && cachedData.v > d.v) {
                  return;
                }
                modifies = void 0;
                if (opts.shouldPoll && !opts.shouldPoll(d.c, d.docName, d, index, query)) {
                  return;
                }
                if (modifies === void 0) {
                  if (poll) {
                    return runQuery();
                  } else {
                    return db.queryDoc(client, index, d.c, d.docName, query, function(err, result) {
                      var idx, name, r, _results1;
                      if (err) {
                        return emitter.emit('error', new Error(err));
                      }
                      if (result && !cachedData) {
                        result.c = d.c;
                        results.push(result);
                        emitter.emit('diff', [
                          {
                            type: 'insert',
                            index: results.length - 1,
                            values: [result]
                          }
                        ]);
                        return docIdx["" + result.c + "." + result.docName] = results.length - 1;
                      } else if (!result && cachedData) {
                        name = "" + d.c + "." + d.docName;
                        idx = docIdx[name];
                        delete docIdx[name];
                        emitter.emit('diff', [
                          {
                            type: 'remove',
                            index: idx,
                            howMany: 1
                          }
                        ]);
                        results.splice(idx, 1);
                        _results1 = [];
                        while (idx < results.length) {
                          r = results[idx++];
                          name = "" + r.c + "." + r.docName;
                          _results1.push(docIdx[name]--);
                        }
                        return _results1;
                      }
                    });
                  }
                }
              })(d));
            }
            return _results;
          })();
          stream.on('readable', f);
          return callback(null, emitter);
        });
      });
    },
    collection: function(cName) {
      return {
        submit: function(docName, opData, options, callback) {
          return client.submit(cName, docName, opData, options, callback);
        },
        subscribe: function(docName, v, callback) {
          return client.subscribe(cName, docName, v, callback);
        },
        getOps: function(docName, from, to, callback) {
          return client.getOps(cName, docName, from, to, callback);
        },
        fetch: function(docName, callback) {
          return client.fetch(cName, docName, callback);
        },
        fetchAndObserve: function(docName, callback) {
          return client.fetchAndObserve(cName, docName, callback);
        },
        queryFetch: function(query, opts, callback) {
          return client.queryFetch(cName, query, opts, callback);
        },
        query: function(query, opts, callback) {
          return client.query(cName, query, opts, callback);
        }
      };
    },
    destroy: function() {
      var id, s, _results;
      redis.quit();
      redisObserver.quit();
      _results = [];
      for (id in streams) {
        s = streams[id];
        _results.push(s.destroy());
      }
      return _results;
    }
  };
};

/*
//@ sourceMappingURL=index.map
*/
